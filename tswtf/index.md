# TypeScript, WTF?

При упоминании про TypeScript представляются два вида разработчиков. Одни хвалят его за мощную систему типов, её пользу в обеспечении корректности программ и в улучшении продуктивности разработки. Другие считают, что TypeScript - это лишняя сложность на проекте, что он приносит с собой много проблем и в итоге снижает продуктивность. Первые любят писать "трёхэтажные" типы и максимально строго типизировать код, который на первый взгляд типизировать невозможно. Вторые считают, что не все способны освоить на должном уровне TypeScript, и что проще вообще отказаться от типов и писать код с применением других известных "лучших практик".

Очевидно, что при всей своей популярности TypeScript имеет проблемы. В этой статье система типов TypeScript будет рассмотрена частично с теоретической стороны, чтобы показать нюансы и компромиссы, на которые пошли разработчики компилятора, и немного оглядеться по сторонам, чтобы понимать, какие есть альтернативные решения.

## Предисловие

Всем привет!
Меня зовут Василий Алфертьев. Я в последнее время front-end разработчик. За свою карьеру успел пройти через C++, системное программирование, Java-backend и прочие докеры, микросервисы... С самого универа я увлекаюсь дизайном языков программирования, компиляторами и математическими основами, которые за ними стоят. Фанат систем типов. Любил погружаться в вопросы математической логики, теорию доказательств и основания математики.

Пока весь мир сходит с ума от нейросетей, считая их синонимом искусственного интеллекта, я не теряю веру в востребованность более строгих методов машинного обучения, основанных на формальных системах для представления знаний и на логических рассуждениях. Компиляторы в своём классическом виде имеют мало отношения к машинному обучению. Но некоторые компиляторы содержат такие сложные алгоритмы доказательства утверждений о программах, что кажутся интеллектуальными. А их качественная интеграция с IDE может дать большую продуктивность разработки, чем LLM наподобие Copilot.

В этой статье я хочу обратить внимание на систему типов TypeScript. Некоторые проблемные моменты давно всем очевидны. Разработчики на TypeScript с опытом не удивятся тому, что я сейчас расскажу. Но никто из нас не становился сразу опытным. Я тоже был когда-то наивным и имел неоправданные ожидания от технологий, и лишь со временем открывал для себя нюансы, с которыми нужно быть внимательнее. И да: я отношусь скорее к первому типу разработчиков, которые готовы писать "трёхэтажные" типы и выступают за максимальное доказательство корректности программ во время компиляции. Но чем больше моему опыту открывается спорных моментов, тем сдержаннее мой энтузиазм.

## Коротко про TypeScript

Итак, TypeScript - это язык программирования, который расширяет синтаксис JavaScript типами, а также JSX и некоторыми специфичными конструкциями, о которых сейчас не будем. Он транспилируется в JavaScript с минимальными трансформациями, что позволяет программисту оставаться в ментальной модели JavaScript при разработке и отладке, а также почти бесшовно использовать множество JavaScript-библиотек из экосистемы NPM.

Я познакомился с TypeScript ещё до версии 2.0. Ещё с выходом 2.0 и добавлением флагов strict я проникся возможностями, которые открывает система типов. При своей простоте, она богатая, гибкая, выразительная. С каждой версией в ней исправляются недочёты и учитываются моменты, существенные при практической разработке. При этом разработчикам языка удаётся балансировать, чтобы не ломать обратную совместимость

Хвалят за:

- Предотвращение runtime-ошибок (TypeError)
- Продуктивность разработки (поддержка в IDE)
- Документируемость кода и API
- Прививание хорошего стиля кода
- Производительность за счёт избавления от необходимости лишних проверок в runtime

Ругают за:

- Ненадёжная система типов
- Слабо типизированная стандартная библиотека JavaScript
- Неактуальные “.d.ts”-файлы для JS-библиотек
- Высокий порог входа (“трёх-этажные типы”)
- Борьба с ошибками компиляции

Некоторые проблемы системы типов TypeScript:

- Намеренное нарушение:
  - any - неявное приведение к чему угодно
  - as, type guards и d.ts-файлы - ненадёжные и потенциально ошибочные
- Отключено по-умолчанию в strict-режиме (но можно включить)
  - [ ] - Значение по индексу у объекта или массива может быть undefined
- JavaScript - бесшовное взаимодействие
  - всё any по-умолчанию
  - Слабо типизированная стандартная библиотека JavaScript
  - "Магия" изменяемых прототипов, дескрипторов properties, Object.freeze, Proxy, переопределение instanceof, оператор delete…

Есть много мест, где типизация нарушается. Где-то это происходит по желанию самого разработчика, а где-то связано с бесшовной интеграцией с JavaScript, который динамически типизирован и имеет столько магии и допускает такие приёмы программирования, которые просто тяжело или невозможно типизировать. Но есть рискованные моменты и в, казалось бы, "строгом" коде, где всё вышеперечисленное исключено или находится под контролем.

## Что есть система типов

Язык программирования представляет собой *формальную систему*, состоящую из **спецификации** и **реализаций**, на которые могут опираться **инструменты**. Спецификация языка - это **синтакис** исходного кода и его **семантика**. Реализация может представлять собой *интерпретатор* с некоторой средой исполнения или *компилятор*, который транслирует исходный код в код для целевой среды исполнения. Инструментами, сопровождающими язык, являются различные *анализаторы* кода, *отладчики*, *IDE*.

Для обсуждения систем типов важна будет семантика. В формальном виде, семантика - это набор правил, определяющих смысл выражений исходного кода. Эти правила описывают процесс вычисления выражений, порядок исполнения действий и другие правила, тем или иным образом раскрывающие смысл выражений.

JavaScript имеет спецификацию ECMAScript, где строго определены синтаксис и семантика различных версий языка и поведение его стандартной библиотеки. **TypeScript не имеет спецификации в формальном виде.** Подразумевается, что смысл исходного кода на языке TypeScript определяется реализацией компилятора tsc (исходный код которого громоздкий и не самый простой). Это ещё одна проблема TypeScript, которая не позволяет легко рассуждать о языке, пристально изучать его, разрабатывать для него инструменты и альтернативные реализации.

Целевая среда исполнения с которой связана реализация языка программирования, тоже может рассматриваться в виде спецификации её поведения отдельно от деталей реализации, которые не интересны при рассуждениях. Предполагается, что реализация среды исполнения соответствует её спецификации. Семантика языка программирования, реализация которого предполагает использование определённой среды исполнения, может быть выражена через её спецификацию.

Целевой средой исполнения для TypeScript является среда исполнения JavaScript-кода. Можно было бы описать семантику TypeScript как отображение на семантику JavaScript. При желании можно было бы написать формальную спецификацию TypeScript и как она соотносится с JavaScript, но разработка TypeScript такая активная, что этим никто не занимается и считается нецелесообразным. Тем не менее, некоторая подразумеваемая спецификация, зашитая в компилятор, у нас как бы есть.

Теперь вспомним, что исходный код пишется для решения задач, алгоритм которых можно сформулировать на своём предметно-специфичном языке спецификаций. Доказательство того, что результирующее поведение программы будет соответствовать формальной спецификации решения задачи, называется *верификацией*.

## Проблемы системы типов TypeScript

Всё это следствие того, что TypeScript, несмотря на своё название, ставит перед собой другие цели. Обеспечение строгой корректности не является целью. Система типов ослаблена в таких местах, чтобы можно было продолжать писать в привычном стиле, как на JavaScript, а также, постепенно добавлять типы в существующий код на JavaScript без его существенного переписывания.

## Альтернативы TypeScript
