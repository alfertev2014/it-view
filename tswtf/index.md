# TypeScript, WTF?

При упоминании про TypeScript представляются два вида разработчиков. Одни хвалят его за мощную систему типов, её пользу в обеспечении корректности программ и в улучшении продуктивности разработки. Другие считают, что TypeScript - это лишняя сложность на проекте, что он приносит с собой много проблем и в итоге снижает продуктивность. Первые любят писать "трёхэтажные" типы и максимально строго типизировать код, который на первый взгляд типизировать невозможно. Вторые считают, что не все способны освоить на должном уровне TypeScript, и что проще вообще отказаться от типов и писать код с применением других известных "лучших практик".

Очевидно, что при всей своей популярности TypeScript имеет проблемы. В этой статье коротко рассмотрим, что из себя представляет система типов TypeScript и какие в ней есть проблемы.

## Предисловие

Всем привет!
Меня зовут Василий Алфертьев. Я в последнее время front-end разработчик. За свою карьеру успел пройти через C++, системное программирование, Java-backend и прочие докеры, микросервисы... С самого универа я увлекаюсь дизайном языков программирования, компиляторами и математическими основами, которые за ними стоят. Фанат систем типов. Любил погружаться в вопросы математической логики, теорию доказательств и основания математики.

Пока весь мир сходит с ума от нейросетей, считая их синонимом искусственного интеллекта, я не теряю веру в востребованность более строгих методов машинного обучения, основанных на формальных системах для представления знаний и на логических рассуждениях. Компиляторы в своём классическом виде имеют мало отношения к машинному обучению. Но некоторые компиляторы содержат такие сложные алгоритмы доказательства утверждений о программах, что кажутся интеллектуальными. А их качественная интеграция с IDE может дать большую продуктивность разработки, чем LLM наподобие Copilot.

В этой статье я хочу обратить внимание на систему типов TypeScript. Некоторые проблемные моменты давно всем очевидны. Разработчики на TypeScript с опытом не удивятся тому, что я сейчас расскажу. Но никто из нас не становился сразу опытным. Я тоже был когда-то наивным и имел неоправданные ожидания от технологий, и лишь со временем открывал для себя нюансы, с которыми нужно быть внимательнее. И да: я отношусь скорее к первому типу разработчиков, которые готовы писать "трёхэтажные" типы и выступают за максимальное доказательство корректности программ во время компиляции. Но чем больше моему опыту открывается спорных моментов, тем сдержаннее мой энтузиазм.

## Коротко про TypeScript

Итак, TypeScript - это *язык программирования*, который расширяет синтаксис JavaScript типами, а также JSX и некоторыми специфичными конструкциями. Он *транспилируется* в JavaScript с минимальными трансформациями, что позволяет программисту оставаться в ментальной модели JavaScript при разработке и отладке, а также почти бесшовно использовать множество JavaScript-библиотек из экосистемы NPM. Разработка компилятора языка (`tsc`) и инструментов IDE (использующих Language Server Protocol, LSP) ведётся компанией Microsoft по модели open-source на GitHub.

Я познакомился с TypeScript ещё до версии 2.0. С выходом 2.0 и добавлением флагов strict я проникся возможностями, которые открывает система типов. При своей простоте, она богатая, гибкая, выразительная. С каждой версией в ней исправляются недочёты и учитываются моменты, существенные при практической разработке. При этом разработчикам языка удаётся балансировать в добавлении новых возможностей в язык, чтобы не ломать обратную совместимость.

**Преимущества**, которые даёт TypeScript:

- Предотвращение некоторых ошибок в runtime (таких как `TypeError`)
- Продуктивность разработки (поддержка в IDE и возможность рефакторинга)
- Документируемость кода и API
- Прививание хорошего стиля кода
- Производительность за счёт избавления от необходимости лишних проверок в runtime

При этом TypeScript постоянно преследуют его **недостатки**:

- Ненадёжная система типов
- Слабо типизированная стандартная библиотека JavaScript
- Неактуальные “.d.ts”-файлы для JS-библиотек
- Высокий порог входа (“трёх-этажные типы”)
- Борьба с ошибками компиляции (когда просто сдаёшься и используешь `any`)

## Проблемы системы типов TypeScript

Под **надёжностью** (soundness) системы типов понимается *гарантия* того, что выведенные типы выражений соответствуют значениям, которые получатся во время выполнения программы. Надёжность системы типов не является приоритетной целью в разработке языка TypeScript. Первоочередное внимание уделяется практической пользе при постепенном добавлении типов в существующий JavaScript-код и постепенном увеличении их строгости, что известно как **gradual typing**. И на данный момент нет способов сделать код на TypeScript достаточно строгим, чтобы гарантированно избегать ошибок в runtime.

Причины ненадёжности системы типов можно поделить на следующие группы:

- Намеренное нарушение надёжности
- Отключаемая надёжность (флаги strict)
- Взаимодействие с JavaScript-кодом
- Врождённые проблемы в дизайне языка

- JavaScript - бесшовное взаимодействие
  - всё any по-умолчанию
  - Слабо типизированная стандартная библиотека JavaScript
  - "Магия" изменяемых прототипов, дескрипторов properties, Object.freeze, Proxy, переопределение instanceof, оператор delete…

Под намеренным нарушением надёжности понимаются места в коде, где программист намеренно нарушает правила системы типов. Это явное использование типа `any`, явные приведения типов с помощью `as`, пользовательские предикаты типов (с ключевым словом `is`), декларации с помощью `declare` и `.d.ts`-файлы. В этом случае он берёт ответственность за ошибки типизации на себя. Это не так плохо, как может показаться, потому что потенциальные места ошибок находятся под его контролем.

Степень надёжности системы типов TypeScript можно настраивать включением и выключением флагов компиляции (секция `compilerOptions` в файле `tsconfig.json`). В качестве примеров можно привести `noImplicitAny`, `noImplicitThis`, `noUncheckedIndexedAccess`, `strictNullChecks`, `strictFunctionTypes`, `strictBindCallApply`, `useUnknownInCatchVariables`, `exactOptionalPropertyTypes` и т.д. Некоторые из этих флагов включаются по-умолчанию при включении флага `strict`. Чем больше включается таких флагов, тем строже компилятор выполняет проверку типов и меньшее множество программ считаются корректными.

Бесшовная интеграция с кодом на JavaScript имеет свою цену в виде ещё одного источника ненадёжности системы типов. В JavaScript по-умолчанию всё становится `any`, стандартная библиотека типизирована либо слабо, либо недостаточно гибко, `.d.ts`-файлы для сторонних библиотек могут быть ошибочными и неактуальными. Кроме того, стоит всегда помнить про
“магию” изменяемых прототипов и прототипного наследования, дескрипторов свойств через `Object.defineProperty` и `get`ters/`set`ters, `Object.freeze`, `Proxy`, переопределение `instanceof`, оператор `delete`… И проблема состоит в том, что если где-то есть ошибка в JavaScript-коде, то проявиться она может внутри даже самого строгого TypeScript-кода. TypeScript никак не защищается от ошибок на границе взаимодействия с JavaScript. Разработчикам самим нужно применять динамическую валидацию приходящих из JavaScript значений, если требуется повышенная надёжность.

Есть много мест, где типизация нарушается. Где-то это происходит по желанию самого разработчика, а где-то связано с бесшовной интеграцией с JavaScript. Допустим, мы обеспечим строгость кода, где всё вышеперечисленное исключено или находится под контролем. Оказывается, даже в этом случае есть ряд проблем в системе типов, которые по ряду причин до сих пор остаются нерешёнными. Вот лишь некоторые проблемы:

- ковариантное поведение объектов с изменяемыми свойствами
- модификатор `readonly` у свойств объектных типов не учитывается при проверке отношения подтипов
- нет способа указать, что объектный тип не допускает изменения состава свойств (например, после `Object.freeze`)
- нет способа указать, что объектный тип не содержит никаких других свойств, кроме перечисленных
- при "встраивании" одного объекта в другой с помощью многоточия или `Object.assign` никак не учитывается, что у объекта могут быть другие свойства, не перечисленные в типе, которые могут "перетереть" свойства итогового объекта значениями неверных типов

## И как с этим быть?

Большинство популярных языков имеют похожие проблемы с надёжностью. Можно вспомнить C++ и его "выстрелы в ногу" при арифметике указателей и undefined behavior. Можно вспомнить Java с её ковариантными изменяемыми массивами и ArrayStoreException. У многих языков просто отсутствует контроль над пустыми значениями (strict nullability). В каких-то языках отсутствуют generics и поощряется "down-casting". Тем не менее, эти языки остаются популярными и активно применяются в разработке программных продуктов. Отсутствие гарантий надёжности компенсируется усиленным контролем над кодом, применением best practices и написанием тестов.

Несмотря на все проблемы системы типов, TypeScript приносит свою пользу, и при грамотном использовании производительность разработки будет лучше, чем на JavaScript без типов. Однако, внедрять TypeScript в кодовую базу JavaScript - это сравнимо с внедрением unit-тестов в код, написанный без учёта тестирования. Потребуется основательный рефакторинг. Для эффективного использования TypeScript требуется поменять мышление и писать не так, как на JavaScript.

Есть менее популярные языки, в которых строгость ставится на первый план. Но можно вспомнить, что языки делятся на два вида: те, которые все ругают, и те, которые никто не использует.