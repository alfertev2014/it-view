
# Введение

Для начала очертим некоторые границы рассуждений как разогрев перед освещением основных тем, потому что просто важно синхронизироваться с читателем и быть с ним на одной волне. Иногда мысли будут доноситься в довольно неформальной форме с применением аналогий для лучшей наглядности.

Весь цикл статей подразумевает достаточно широкий опыт у читателя. Некоторые моменты будет сложно понять, если самому не почувствовать на практике. Чтобы примерно наметить будущее поле для рассуждений, начнём с описательного введения для формирования представления у читателя. Далее каждая глава будет предлагать для рассмотрения тезисы, требующие более глубоких рассуждений.

## Что такое программный продукт

Продукт - это товар или услуга, которую можно предложить для рынка, чтобы удовлетворять потребности потребителей. Само слово "продукт" подразумевает, что его нужно произвести, затратить на это ресурсы, включая труд. В IT можно привести много примеров деятельности, связанной с производством и применением программных продуктов:

* *разработка* - создание нового продукта, добавление новых *фич* в существующий продукт, развитие и повышение качества;
* *сопровождение* - техническая *поддержка* пользователей, исправление ошибок, модернизация систем;
* *исследование* - проведение *экспериментов* с IT-решениями с целью оценить концепцию, поиск новых возможностей;
* *консалтинг* - помощь в *принятии решений*, требующих технической экспертизы, обычно на этапе проработки архитектуры;
* и т.д.

Сам по себе программный продукт - это либо программно-аппаратная система, либо услуги, связанные с программно-аппаратной системой. Чаще всего они связаны с артефактами разработки, такими как программный код и способами его доставки - установки или развёртывания. Немало важным остаётся и вопрос чтения и понимания кода разработчиками для дальнейшего сопровождения. Поэтому вместе с кодом обычно формируется документация. Всё вместе это выглядит как единый "пакет", содержащий:

* *исходный код* (source code) вместе с различными встроенными файлами (assets);
* *конфигурацию сборки*;
* *артефакты* сборки, готовые для доставки;
* *конфигурацию* работающей системы с возможностью её изменения оператором, возможно, даже без перезапуска системы;
* *техническую документацию* на исходный код и на конфигурации, на процесс сборки и развёртывания;
* *пользовательскую документацию* на UI (или API) и возможности конфигурирования системы оператором
  
Не всегда IT-услуги состоят в разработке такого пакета. Есть деятельность, не связанная с конкретным программным продуктом. Например, администрирование больших кластерных систем - это уже услуги инфраструктуры, на которой работают программные системы различных продуктов. Сюда относятся:

* обслуживание узлов кластера и сети, учёт вычислительных ресурсов, хранилищ и сетевой связности;
* обеспечение конвейера развёртывания или доставки (deployment/delivery pipeline),
* администрирование хранилищ артефактов сборки, в том числе различных репозиториев для пакетных менеджеров и реестров контейнетов;
* мониторинг работающей программной системы и инфраструктуры, на которой она развёрнута, снятие метрик, обеспечение наблюдаемости (observability) за внутренней работой системы;
* системы оповещения об инцидентах (alerting) и инфраструктура для их разбора.

Ещё один особенный пример - это разработка клиентских приложений, которые должны работать на неизвестном количестве самых разнообразных устройств. Это десктопные приложения, мобильные приложения, web-приложения, работающие в браузерах. Для них актуальны вопросы

* кросс-платфроменности и совместимости,
* адаптируемости под различные платформы и их наполнение,
* распространения и доставки обновлений,
* доверия и безопасности,
* сбор обратной связи, включая отчёты об ошибках.

Веб-приложения распространяются через хостинг или сеть доставки контента (CDN), мобильные приложения распространяются через магазины приложений, десктопные приложения могут распространяться как архивы с установочными файлами или поставляться через пакетные менеджеры в операционной системе. К отдельным пакетам могут добавляться электронные подписи, рейтинг и отзывы пользователей для решения вопросов доверия разработчикам и обратной связи.

Существуют программные продукты по сборке и наполнению целых операционных систем. Это могут быть различные дистрибутивы Linux, репозитории с пакетами RPM, Deb и других пакетных менеджеров. Существует много дистрибутивов для встраиваемых устройств (embedded), для которых часто требуется своя специализированная сборка операционной системы, сильно отличающаяся от популярных. Для любого дистрибутива встаёт вопрос управления наполнением системы в виде пакетов, их версионирования, сопровождения, сборки и доставки до устройств.

Програмный продукт - это всегда про применение IT-технологий для решения проблем пользователей как конечных *потребителей*. Пользователи мыслят в терминах своих потребностей, поэтому для их удовлетворения программная система должна отражать модель мышления пользователей. Это прежде всего предметная область (domain) и пользовательский опыт (user experience, UX). Поэтому прежде чем приступать к разработке, сначала требуется исследовать предметную область, проблемы пользователей как потребности потребителей, сформировать идею по внедрению IT-решения, к которому сформулировать *требования*.

С другой стороны, *производители* программных продуктов имеют в своём арсенале набор IT-технологий, из которых возможно собирать продукт, чтобы уложиться в поставленные требования. На каждом этапе истории IT был свой набор технологий, возможности которых являлись границей удовлетворения потребностей пользователей.

Технологии развиваются и конкурируют друг с другом подобно видам живых организмов. Потому часто можно встретить слово *экосистема*. Со временем происходит эволюционный переход технологий, IT перестраивается под новые реалии и представления об эффективном производстве. Когда возможности IT расширяются, потребности пользователей тоже могут вырасти, пока не наступает качественное изменение пользовательского опыта. Сами IT-технологии своими возможностями могут диктовать пользователям новые способы удовлетворения новых потребностей, перестраивая их образ жизни как потребителей. Но это уже отдельный вопрос, которого касаться не будем в этой статье.

## Что такое процесс разработки

Не важно, занимается ли производством программного продукта один человек или целая команда, вся последовательность от идеи до результата подчиняется определённому процессу разработки. Продукт может разрабатываться по частям, а не весь целиком, некоторые части приходится переделывать под новые требования, поэтому процесс не всегда удаётся представить линейной последовательностью этапов. Чаще это будет циклы, или *итерации*, со следующими фазами:

* Анализ:
  * появление идеи создания нового или добавления в существующее;
  * оценка эффекта на рынке и принятие решения о разработке;
  * сбор сведений о предметной области и ограничениях;
  * проработка требований - функциональных и нефункциональных;
* Проектирование
  * разработка архитектуры решения (solution architecture);
  * возможно, более тщательное изучение применяемых решений, проведение исследований для подтверждения концепций;
  * подбор и привлечение необходимых инженерных ресурсов с нужными компетенциями в соответствии с решением;
  * настройка и администрирование средств разработки, сопровождения, развёртывания и мониторинга;
  * проработка системных постановок, моделей системы, контрактов взаимодействия её частей;
* Реализация
  * создание или донастройка проекта, системы сборки и подключения необходимых зависимостей;
  * непосредственное написание кода в соответствии с системными постановками;
  * модульное и интеграционное тестирование в соответствии с системными постановками;
  * отладка, исправление ошибок, рефакторинг;
  * code review;
  * слияние изменений в ветку для релиза;
  * сборка и прохождение автоматических этапов контроля качества (quality gates) в пайплайне;
  * обновление технической документации;
* Тестирование
  * настройка тестовых стендов и инфраструктуры для тестирования;
  * написание тест-плана и тест-кейсов в соответствии с системными постановками;
  * разработка ручных и автоматических тестов, генерация тестовых примеров;
  * прогон тестов на определённом релизе;
  * регистрация багов и оформление отчётов тестирования (test report);
* Доставка
  * формирование артефактов релиза;
  * загрузка артефактов в средства распространения релиза или в пайплайн развёртывания релиза;
  * возможно, проведение плавного развёртывания, A/B-тестирования, "канаречного" релиза, "бета"-тестирования;
* Мониторинг и поддержка
  * сбор данных о работе системы;
  * сбор обратной связи от пользователей;
  * выявление аномалий и идей (insights) по улучшению работы системы и процессу разработки;
  * регистрация инцидентов в системе оповещения (alerting);
  * разбор инцидентов и назначение ответственных.

В процессе разработки могут участвовать много людей с различными ролями и обязанностями. Вот лишь некоторые их них:

* владелец продукта (product owner);
* бизнес-аналитик;
* архитектор решения (solution architect);
* технический лидер (techlead);
* системный аналитик;
* UI/UX-дизайнер;
* руководитель проекта (project manager, PM);
* разработчик;
* тестировщик;
* лидер команды разработки, аналитиков или тестировщиков (teamlead);
* системный администратор (их стали называть DevOps-инженерами);
* Site Reliability Engineer (SRE);
* специалист техподдержки (customer support);
* scrum-master или любая другая роль по организации процесса разработки;
* и т.д.

Некоторые роли могут сочетаться между собой, несколько ролей может брать на себя один сотрудник. В любом случае эти роли присутствуют в разработке и каждая имеет свой набор обязанностей.

Стоит отметить, что параллельно процессу разработки происходят ещё несколько процессов:

* управление и планирования ресурсами разработки;
* сбор сведений о трудозатратах для оплаты труда, определения KPI и идей по оптимизации процесса;
* подбор персонала в соответствии с потребностями проекта по количеству ресурсов и компетенциям;
* продажа и получение дохода от использования продукта.

Эти процессы существенно влияют на сам основной процесс разработки.

## Что такое код

Под кодом можно понимать любой текст или иной исходный материал (конфиги, диаграммы и т.п.), который определённым образом строго моделирует определённую часть разрабатываемой системы. Код может существовать и сам по себе без привязки к программной системе для того, чтобы его анализировали и делали различные выводы. Хочется подчеркнуть, что в этой статье понятие кода будет достаточно широкое. Это не просто текст программы на конкретном языке программирования. Это может быть любая редактируемая человеком информация в определённой форме представления, из которой складывается программный продукт в результате процесса сборки. Это также может быть и производная от неё информация, как, например, результат кодогенерации, трансляции, сборки в промежуточное представление. Такой код не предназначен для редактирования человеком, хотя всё ещё может быть им прочитан.

В последние десятилетия набрали популярность идеи с общим названием "as a code". Код может быть не только для программы, но и:

* infrastracture as a code - описание IT-инфраструктуры может быть выполнено в виде кода;
* configuration as a code - рассматривает работу с конфигурациями как с кодом;
* DevOps pipeline as a code - когда пайплайн сборки и развёртывания описывается кодом;
* data analysis as a code - пайплайны обработки данных и машинного обучения описываются кодом;
* security as a code - когда управление ролями и разрешениями, включая "чувствительные" данные (secrets), требующие шифрования, представляется в виде кода;
* и т.д.

Такое широкое понятие кода подразумевает работу с такими разнообразными сведениями с помощью тех же средств, применяемых для работы с кодом. Это в первую очередь система контроля версий, влекущая за собой code review и прохождение автоматического пайплайна. Это также поддержка со стороны IDE.

Любой код - это не просто порция данных, это особые данные, которые предназначены для интерпретации. Иными словами, это не данные, имеющие практический смысл сами по себе, а их смысл определяется другой программой. Код представляет собой текст на определённом языке, у которого есть свои синтаксис и семантика. Программа-интерпретатор (или транслятор) может прочитать код в соответствии с синтаксисом и наделить его смыслом по правилам семантики.

Даже обычный конфигурационный файл можно рассматривать как код, потому что он должен быть прочитан программой, для которой он создан, по правилам его синтаксиса - пусть иногда и очень простого. И смысл конфирурационного файла в том, как его проинтерпретирует программа, прочитающая его. Языки можно классифицировать по уровню от универсальных до совсем специализированных. Конфигурационные файлы просто имеют очень специализированный язык, семантика которого задаётся интерпретацией в программе, которая его считает. Бывают конфигурационные файлы, обладающие довольно богатыми возможностями, но всё ещё не дотягивающими до универсальных языков. Языки разметки, например, XML, HTML, и им сопутствующие XSLT, CSS, являются примерами достаточно богатых языков, но всё ещё не языками программирования. Мы всё равно будем называть текст на этих языках кодом, потому что это не простые форматы данных, а они требуют интерпретации с определённым уровнем сложности.

Код обычно не существует сам по себе в том виде, как он описан интерпретатором. Он чаще представлен в виде фрагментов, организованных, например, в виде файлов, или иных способов разделения единой программы на куски. Эти куски могут храниться на локальной файловой системе, загружаться по сети, формироваться в оперативной памяти на лету и даже находиться внутри фрагментов кода на других языках. В связи с этим возникает много практических вопросов об организации программ и их работе в составе программно-аппаратной системы. Что есть целая программа в понимании некоего интерпретатора? Код программы может быть разделён на куски, которые хранятся в файлах, которые должны быть как-то собраны в единое целое перед их исполнением как целой программы. А может быть ситуация, когда к интерпретатору подкладываются файлы, и он без особой сложной логики подгружает их на лету, как плагины. Ещё можно вспомнить про использование зависимостей, которые предполагаются содержащимися в системе или требуют предварительной установки по сети.

Вот лишь несколько примеров организации частей кода, с которыми связано много дополнительных практических вопросов:

* модули и модульная система
  * модули времени исполнения, которые загружаются интерпретатором напрямую (файлы скриптов, динамические библиотеки)
  * модули времени сборки, например, translation unit и статическая линковка в C
  * модули на уровне исходного кода, из которых собираются другие куски исходного кода, например, header-only библиотеки С++
* метапрограммирование
  * простая кодогенерация шаблонизатором
  * препроцессоры, расширяющие основной язык
  * полноценные программы, генерирующие другие программы
* dependency injection во время исполнения и aspect oriented programming (AOP)
  * компоненты программы с жизненным циклом под управлением DI-контейнера
  * аспекты, действующие между этими компонентами во время "сшивания" (weaving)
  * генерация связывающего (мостового) кода между компонентами во время сшивания аспектов
* разделение программы на декларативную "вёрстку" и логику
  * полноценные отдельные языки для "вёрстки" (HTML, CSS, XML, QML)
  * внутренние domain specific languages (DSL)
* встраивание фрагментов кода в код на другом языке
  * встраивание фрагментов более низкого уровня, чем основной язык, например, ассемблерные вставки в C
  * встраивание фрагментов кода более высокого уровня, например, JPQL в JPA-аннотациях
  * встраивание фрагментов кода на совсем другом языке, передаваемые определённому интерпретатору, например, встроенный SQL, Lua, JSON, HTML, XML
* скрипты
  * полноценный язык скриптов для запуска других программ из большого набора в системе, например, Bash
  * скрипты сборки проектов и автоматизации, по сути аналогичные Bash, только более специализированные и иногда специально ограниченные
  * workflow-движки, например, BPMN, GitHub Actions
* пакеты и пакетные менеджеры
  * системные пакетные менеджеры для наполнения системы из репозиториев дистрибутива
  * пакетные менеджеры зависимостей для разработки, например, maven, pip, rake, npm, conan
  * файлы описания пакетов со списоком зависимостей
  * файлы конфигурации логики удовлетворения зависимостей
  * файлы для запуска логики сборки пакета из исходников и формирования результирующих пакетов
* и т.д.

Работа с кодом становится существенно сложнее, когда появляются моменты смешивания языков, например, встраивания, а также когда распространение фрагментов кода становится нетривиальным, как например установка пакетов по сети. Сюда добавляются ещё вопросы версионирования и совместимости, доверия и безопасности, инфраструктурные вопросы организации репозиториев или ограничений на доступ в сеть.

Часто смысл одного кода определяется через смысл другого кода путём определённой трансляции, которую выполняет третий код. Который, в свою очередь... И так далее. Всё это выглядит как большая неконтролируемая смесь, с которой приходится иметь дело человеку, чтобы задействовать возможности аппаратного обеспечения. Чтобы такой растущей сложности не происходило, для этого и применяются абстракции и математика. Они позволяют отделить слои в программной системе таким образом, чтобы можно было не задумываться об остальных слоях, просто пользоваться моделью интересующего слоя, полагаясь на то, что гарантии этой модели будут обеспечены каким-либо иным способом за нас.

С этого момента должно стать понятно, что разработчики программных систем (программисты, аналитики, дизайнеры, и т.д.) работают не просто с кодом как с каким-то текстом, а с моделями и абстракциями. Языки для написания кода проектируются таким образом, чтобы эти модели легче понимались людьми, чтобы о них легче можно было рассуждать и обеспечивать гарантии. Часто эти функции можно отдать автоматическим инструментам. Но любые автоматические инструменты требуют строгости и определённой полноты описания абстракций, с чем и помогает математика.

## Что такое язык

Любая работа с кодом и абстракциями вокруг него всегда связана с понятием *языка*. Языком можно считать набор правил, определяющих множество осмысленных последовательностей букв или слов. Эти последовательности в общем случае называют строками, состоящими из элементов множества определённого фиксированного алфавита. Теория языков и методов трансляции является основным инструментом при рассуждениях о коде.

Язык - это множество строк определённого *алфавита*. Язык определяется *синтаксисом* и *семантикой*.

Синтаксис - это набор правил, определяющих множество строк, принадлежащих языку. Они могут быть заданы в виде *грамматики* или в виде *проверяющего автомата* - программы, реализующей предикат принадлежности строки языку.

Семантика - это способ наделить строки языка смыслом. Есть разные способы задать семантику. В любом случае надо понимать, что сам смысл строк - это абстрактные объекты. И семантика - это просто способ отображения строк языка на множество таких абстрактных объектов. Этими объектами могут быть, например, действия вычислительной машины.

Есть прямой способ задать семантику как функцию отображения строк языка в абстрактные объекты смысла. Это называется *денотационная семантика*. Для одних языков этот способ может быть удобным, для других слишком сложным для понимания. Часто применяется подход, при котором семантика одного языка определяется через семантику другого более простого языка, для которого можно определить абстрактную машину, моделирующую смысл выполняемых операций. Из языка исходного кода в язык абстрактной машины определяются правила преобразования (переписывания) исходной строки. Последовательным применением таких правил можно привести исходную строку к строке, обозначающей смысл. Так задаётся *операционная семантика*.

Если строка, подаваемая на абстрактный интерпретатор, приводит к ошибочному состоянию, то считаем, что такая строка не имеет смысла. Ошибочным состоянием может быть, например, тупиковое состояние интерпретатора, когда он не знает, какой шаг сделать дальше, а программа всё ещё находится не в финальном состоянии. Ошибочным можно считать любой выход за пределы абстракции. Такой выход, например, называют неопределённым поведением (undefined behaviour). Ещё можно рассматривать как ошибочные ситуации, в которых исполнение программы зацикливается или никогда не останавливается, хотя в некоторых случаях это можно считать допустимым поведением.

Когда для языка задана семантика в любой формальной форме, над строками этого языка уже можно вести строгие рассуждения математическими методами. Разработка таких методов рассуждений руководствуется практическими целями. Как минимум, надо научиться определять, имеет ли исходная строка смысл в заданной семантике, без необходимости запуска строки на исполнение и прохождения всех шагов. Например, одной из важнейших целей является доказательство корректности программы, отсутствия в ней определённого рода ошибок, доказательство соответствия программы её спецификации, вытекающей из требований.

Основная проблема такого доказательства даже не в том, что в общем случае оно невозможно, а в том, что на практике очень сложно писать спецификацию поведения программной системы, чтобы она была достаточно полной. Иногда требуется отдельный строгий язык для написания спецификаций, для которого тоже нужно определять семантику. А учитывая, что в разработке программного продукта часто требования имеют большие пробелы или формулируются неформально, то даже в таком языке спецификаций оказывается мало практического смысла. Более того, подробное описание желаемого поведения программы со всеми ограничениями может вылиться в написание кода, по сложности совпадающего или даже превосходящего код самой программы. Поэтому на практике обычно пренебрегают полнотой спецификации.

Обычно применяются ослабленные методы, позволяющие доказать определённые гарантии. Например, система типов. Если система типов строгая (sound), то корректно типизированная программа гарантировано не содержит определённого класса ошибок, на которые эта система типов рассчитана. Система типов часто тесно интегрируется в язык. Прямо в синтаксис добавляются конструкции для деклараций типов. В каком-то смысле такие декларации типов являются маленькими частями спецификации работы программы. Чем гибче система типов, тем больше в ней можно выразить утрвеждений о работе программы.

Строгая система типов всегда исходит из семантики и разрабатывается так, чтобы корректно типизированная программа всегда имела смысл. Иногда это не всегда так. Бывает, что система типов обеспечивает отсутствие меньшего множество ошибок. А иногда наоборот, система типов может быть такой строгой и недостаточно гибкой, что будет считать ошибочными программы, которые могли бы корректно работать. В любом случае, система типов помогает рассуждать не обо всех аспектах программы, а о её ограниченной модели, в которой оставлены только важные детали.

Несмотря на то, что язык - это просто строки с возможностью их интерпретации, подчиняющиеся строгой математике, всё же проектируются языки с рассчётом на использование их человеком. Поэтому в языке может быть много элементов, сделанных специально для человека. Например, самая очевидная возможность - это давать произвольные имена различным сущностям. Интерпретатору всё равно, какие это будут имена, он будет использовать лишь их свойство равенства между собой для идентификации. А человек может выбрать такие имена, чтобы сразу отражать смысл для понимания человеком. Той же цели служат комментарии в исходном коде. Сама форма некоторых синтаксических конструкций выбирается тоже не просто так, а для удобства написания и чтения человеком. С математической точки зрения программы можно даже вручную писать на строго-типизированном языке байткода сразу для целевой виртуальной машины. Но в пригодный для практики высокоуровневый язык программирования добавляются средства для облегчения отображения конструкций языка в человеческие представления.

В идеале, человек мог бы писать ровно на том придуманном языке, который для него максимально удобен как для написания программ, так и для чтения и понимания, при этом оставаясь со строгим контролем семантических ошибок. Для этого языка нужно будет всего лишь написать соответствующий интерпретатор. В этом отчасти и состоит идея доменно-специфичных языков (domain specific language, DSL). Хороший DSL выглядит почти как язык, на котором пишутся системные постановки. Вторым немало важным моментом DSL является ограничение области его применения описанием узкого множества проектно-специфичных абстракций, чтобы не допустить выход за их границы, давая тем самым дополнительные гарантии и возможности для рассуждений. Это отличает DSL от универсальных языков программирования.

Если смотреть с другого конца, даже машинный код реальной вычислительной системы имеет строгий язык инструкций со своими правилами интерпретации и ограничениями. Именно вычислительная система является целевой средой работы программ, которые пишутся на высокоуровневых языках. Если быть точнее, программы пишутся под множество вычислительных систем, обладающим общим интерфейсом исполнения программ. Например, архитектура x86_64 с некоторым фиксированным набором расширений instruction set, охватывает большое множество устройств, поддерживающих интрпретацию такого машинного кода. Поэтому когда компилятор транслирует программу с высокоуровневого языка в машинный код, он тоже пользуется слоем абстракции, описанным в спецификациях на оборудование. То же самое можно сказать, например, про операционную систему, среду исполнения интерпретируемых языки программирования или байткода, браузер.

Слой абстракции - это всегда модель, позволяющая сосредоточить внимание на интересующих сторонах предмета и пренебречь остальными. Любой язык программирования (или конфигурации) задаёт свой слой абстракции, то есть модель, выраженную в его семантике. Именно моделями пытаются мыслить люди, когда у себя в голове начинают рассуждать о коде. Но человеческое мышление никогда не бывает надёжным, поэтому человек заинтересован в существовании инструментов проверки этих моделей для контроля за обеспечением необходимых гарантий. Ведь в конечном итоге он заинтересован в том, чтобы быть уверенным в соответствии разработанной программы поставленным требованиям.

## Что такое модуляризация

Разделение кода или программной системы на модули требуется в первую очередь для двух вещей:

* Структурирование сложной системы для удобного понимания и навигации по ней человеком
* Определение границ абстракций, обеспечивающих изоляцию между частями системы

Из этих моментов вытекает возможность работы со сложной системой по частям, лёгкое внесение изменений в отдельные части без затрагивания всей системы, замена целых частей на другие, выделение повторно используемых блоков для построения целого множества систем. Поэтому многие слои абстракций, такие как языки программирования, языки разметки, языки конфигураций, потребляющие интерпретируемый ими код в больших объёмах, имеют свою модульную систему.

## Что называют экосистемой

Часто бывает, что разработанный слой абстракции оказывается настолько важным и востребованным, что становится публичным. И далее он может существовать как платформа для создания на его основе большого числа других решений. Особенно важные платформы впоследствии становятся стандартами. Примерами таких слоёв абстракций можно назвать языки программирования, интерфейс операционной системы, протоколы взаимодействия и форматы обмена данными, API и ABI различных фундаментальных библиотек, например, libc, libstdc++, JDK, набор инструкций линейки процессоров, байткод и другие средства среды исполнения виртуальной машины. Одним из востребованных свойств таких абстракций является стабильность при развитии во времени и при изменении нижележащих деталей реализации.

В то время как платформа, определяющая слой абстракции, обеспечивает стабильность для неограниченного числа свох потребителей, на её основе появляются решения конкретных задач, которым стабильность и стандартность не так критична. В этом случае появляется полная свобода развития решений бизнес-задач с меньшей публичностью и с меньшим жизненным циклом, чем сама платформа. Они развиваются одновременно большим количеством разных команд как побочный результат реализации конкретных проектов программных продуктов. Из-за того, что они менее публичны, есть большая вероятность, что разные команды в разных проектах независимо друг от друга будут решать одни и те же промежуточные задачи примерно одинаковыми способами, но в результате получат несовместимые между собой решения. При публикации этих решений они становятся конкуррирующими.

Одна из основных идей оптимизации разработки ПО - это переиспользование существующего кода. В данном случае речь идёт о переиспользовании целых решений, которые могут публиковаться для использования другими командами в новых проектах. Когда в каком-либо проекте разработчики начинают решать задачу написанием нового кода при существовании публичного решения той же проблемы, говорят, что они "изобретают велосипед" - имеено в таким высмеивающем ключе. Так закрепляется в культуре разработчиков, что они не должны писать что-то новое, когда до них это уже сделано, потому что есть гипотеза, что применить существующее решение дешевле, чем разрабатывать своё. Поэтому у разработчиков есть потребность в быстром поиске существующих решений, соответствующих возникающим задачам. Ещё разработчику интересно иметь не только сами решения, но и сопровождающие их средства для разработки и отладки, облегчающие опыт разработки (development experience, DX) аналогично пользовательскому опыту (user experience, UX). Так и складывается экосистема вокруг некоторой платформы.

Ещё раз подчеркнём, что платформа (или стандарт) разрабатывается и совместно развивается сообществом или группой компаний для решения целого широкого класса задач. Одна платформа может строиться поверх другой и сужать класс решаемых проблем. Платформы можно расположить по уровню, основываясь на зависимостях между ними, от самых низкоуровневых (связанных с устройствами) до высокоуровневых фреймворков, в которых достаточно файлы конфигурации правильно настроить. Но на их основе разрабатываются решения под конкретные проекты, имеющие более узкое применение.

Экосистема таких узкоприменимых решений имеет следующие аспекты:

* платформа, на основе которой они разработаны
* привязка к версиям платформы и правила обновления на новые версии платформы
* реестр для публикации решений, хранения их версий, например, репозитории пакетных менеджеров, GitHub, Docker Hub
* инфраструктура установки или доставки этих решений для использования в конечном проекте, например, npm install
* возможности поиска решений, их изучения, сравнения для принятия решения об использовании
* сообщество разработчиков или компаний, поддерживающих эти решения, отвечающих на вопросы и учитывающих пожелания их потребителей
* средства общения сообщества - наподобие twitter, списков рассылки, блоги, статьи, специализирванные форумы, групповые чаты и т.д.
* дополнительные средства разработки и отладки, облегчающие использование решения, например, плагины к IDE, React Dev Tools

Экосистема подразумевает существование нескольких несовместимых между собой решений одной и той же проблемы. В этом случае возникает конкурренция. Решения конкурируют за внимание использующих их потребителей. Более востребованные решения получают большую поддержку, обрастают большими средствами, облегчающими разработку, чаще обновляются. Менее востребованные остаются со временем заброшенными, ошибки в них исправляются намного медленнее или вообще не исправляются.

Обычно, популярность решения определяется его эффективностью, отличительными качествами, которые обещают его потребителям менее трудозатратное и комфортное применение. Иногда бывает наоборот, новое ещё сыроватое решение привлекает внимание с помощью различных средств продвижения, тем самым собирая вокруг себя сообщество, которое развивает это решение и делает его по настоящему хорошим. Часто такие случаи называют "хайпом". Большую роль играет доверие разработчиков к бренду, поднимающему такой хайп.

Таким образом, развитие программных решений можно сравнить с процессом эволюции биологических видов. Основным ресурсом, которым они питаются, за который ведут борьбу, является внимание пользователей и трудовых ресурсов для их сопровождения и продвижения. Эти ресурсы, в свою очередь, вторичны по отношению к средствам на рынке (деньги или любой другой капитал) и бизнес-задачам, которые они пытаются решать, у которых происходит своя эволюция. Программные решения и идеи появляются, живут, изменяются, подстраиваются под нишу, иногда даже размножаются, умирают по законам эволюции. Основным "давлением отбора" служит вопрос эффективности при решении бизнес-задач. Именно этот фактор влияет на интерес к решению, на его популярность.

Но делать "велосипеды" - это же плохо? Возникает вопрос, почему вообще должна существовать какая-то конкуренция между решениями? Почему программисты не могут последовательно решить все задачи одним единственным способом, накопить все решения в одно большое хранилище, сохранить его на века и использовать? Идея любого реестра библиотек обычно состоит именно в этом. По крайней мере, стандартная библиотека определённого языка программирования разрабатывается в одном экземпляре. Напрашивается идея так же стандартизировать все решения, написанные под данную платорму, как одну большую стандартную библиотеку. Но этого не происходит. Всему виной человеческий фактор самих разработчиков, у которых ограничен объём внимания, нет времени на поиск и изучение подходящих решений, нет доверия к существующим решениям, так как часто могут встречаться ошибки. Иногда, действительно, проще написать своё, чем разбираться в "зоопарке" существующих решений, потому что вся экосистема может быть просто необозрима целиком в плане решения конкретной задачи, и сами решения могут быть плохо документированы и делать не совсем то, что требуется, или не очень эффективным способом.
