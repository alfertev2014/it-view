# TODO

## Computer science

Любое технологическое решение держится на определённых областях научных знаний. IT не исключение. Совокупность прикладных разделов математики, с помощью которых моделируется работа вычислительных устройств и разрабатываются новые эффективные формы их применения - это и есть *computer science*, пронизывающая всё IT.

Сами по себе вычислительные устройства разнообразны, ещё более разнообразны способы их программирования, а уж сколькими способами можно потенциально применить их в человеческой жизни! Это разнообразие ведёт к взрыву размерностей. Из всевозможных комбинаций вариантов внимание получают лишь те, которые рассматриваются как интересные с точки зрения эффективности как для разработки, так и для эксплуатации. Одной из целей computer science является поиск таких эффективных решений.

Основой computer science выступают математические формальные системы и методы. Большие классы проблем вычислений с помощью технических устройств сводятся к меньшему набору математических проблем, более удобных для рассмотрения и рассуждения. Решение этих абстрактных математических задач влечёт за собой применение аналогичных методов для решения конкретных вопросов computer science. Так проработка теоретических основ в математике окружается разработкой практических методов, которые, в свою очередь, применяются при разработке конкретных проектов.

Теоретические основы знать разработчикам полезно, но не обязательно всем. С теорией больше работают отдельные люди, занимающиеся научной деятельностью. Если для них и важно иметь арсенал методов поиска решения фундаментальных проблем и синтеза новых методов и подходов, то для обычных разработчиков достаточно понимать лишь конечные результаты их деятельности. Точно так же можно выделить программистов, разрабатывающих повторно используемые библиотечные решения, требующие большего погружения в науку, и разработчиков, которые только потребляют эти решения. При использовании готовых решений все научные соображения знать не обязательно, достаточно понять, что гарантирует слой абстракции и какие возможности он открывает.

Как и у любой точной науки, у computer science есть характеристики, позволяющие ей подходить под критерии научности. Эти критерии определяют, что есть наука, а что нет. Такие критерии являются достаточно ограничивающими, из-за чего в науку попадает только малая часть выверенных знаний. Отдельно от науки существуют *инженерные практики* в IT. Это может быть слабо структурированная коллекция нечётких советов и наблюдений в области практики. Они не могут быть включены в науку в качестве научных знаний, но тем не менее имеют полезность в конкретных проектах.

Математические проблемы computer science рассматриваются через призму полезности решения практических проблем. А полезность руководствуется конкретными проектами, конкретными доменами.

Есть движение в развитии инженерных практик, потому что надо делать текущие востребованные проекты из того, что есть сейчас.

Есть движение в науке, которое заполняет пробелы существующей базы знаний и ищет новые идеи

Пройтись по идеям и показать, почему вот таким стал Паскаль, почему таким стал JavaScript.
Что будет, если с нуля попробовать придумать что-то подобное, учитывая идеи трёх полюсов.

### Алгоритмы и модели

Формальные системы, моделирование вычислительной техники. Алгоритмы и классы задач.

### Теоретическое программирование

Теория языков программирования, синтаксис, семантика, трансляция. Рассуждения о программах на основе семантики.

Формальная верификация, языки спецификации.

Системы типов.

Сети Петри, корутины.

### Текущая ситуация

Что с существующими языками и инструментами. Какие есть проблемы.

Конь не валялся

## Паттерны и абстракции

Математические возможности языков и технологий рассчитаны для построения абстракций.

Абстракция - это вычленение чего-то важного для конкретного вопроса из всего неважного.

Предел абстрагирования - математика.

Абстракция и слои.

Базовый язык позволяет делать всё, в том числе выстрелить в ногу.

Компилятору и среде исполнения вообще не известно, что программист имел ввиду. Но программист держит в голове паттерн, даёт частям программы имена, чтобы лучше отображать её семантику на своё мышление.

Неявные паттерны в голове vs. явные абстракции в коде.

Сильные абстракции vs. дырявые абстракции.

Универсальное vs. специальное решение.

SOLID и тому подобные служат, чтобы иметь дело с изменениями.

Библиотеки, фреймворки, платформы, CMS, LowCode, коробочные решения.

Если в базовый язык добавить библиотечку с абстракцией, будет функциональность этой библиотеки + язык. Библиотека как бы расширяет язык, но не ограничивает его. Ограничение для языка - создание нового языка.

DSL. Конфиги.

## Парадигмы программирования

Исходим от трёх полюсов. Декларативное и не декларативное.

Метафоры моделирования задач переносятся на программирование.

Не стоит применять парадигму, если задача вместе с идеей её решения сформулированы в другой парадигме.

## Методологии разработки

Основна всех методологий: программа строится на основе требований. Чтобы описать требования, нужен отдельный язык спецификации.

Декомпозиция задачи.

Кубик рубика. Движение по состояниям. Инкрементальная разработка. Пространство свободы для выбора реализаций.

Преждевременная оптимизация. Преждевременная генерализация. Преждевременная типизация.

Сверху-вниз и снизу вверх. TDD. Связь тестов и типов.

Инкапсуляция. Сначала реализация, а потом закрытие в капсулу vs. Сначала явный интерфейс капсулы, а потом проработка реализации.

Разработка с середины, DDD, LOP.

Legacy и рефакторинг.

Аналитики vs. программисты.


## Анализ и проектирование

Классификация информационных систем: от статических сайтов до систем учёта


## Обучение и обмен знаниями

Популярно не то, что хорошо, а то, что модно.

Популярно то, что легко.

Хорошо забытое старое. Раньшебылолучше (нет).

Фрагментация технологий, несовместимость, стеки.

Кривая обучения технологий. Изучение стека вглубь и вширь.

Документация. Overview. Гайды. Мануалы. Книги. Stackoverflow. Статьи. Видосы. Конференции. Курсы. Менторство. Университеты?

Проблема выбора решения. Не проще ли написать велосипед?

Проблема создания и внедрения новых хороших идей. Проблема велосипедов и 14 стандартов.

Проблема NPM-помойки.

До каких высот нужно дойти, чтобы начать приносить пользу?

Прокладывая дорогу к высотам, как её облегчить для последующих?

## Трудозатраты и когнитивная нагрузка

Почему важно овладеть IDE и инструментами, чтобы делать всё быстрее.

## Распространение и доставка решений

Модули и пакеты. Ад зависимостей. Коробочные решения в виде бандлов и проблема места на диске.
