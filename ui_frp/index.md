# UI-Фреймворки, Декларативный подход и Реактивное программирование

## Введение

В этой статье будут рассматриваться вопросы устройства UI-фреймворков, их архитектура и детали реализации. Одной из интересных тем является большая роль идей *функционального-реактивного программирования*, а также вопрос, какова роль *объектно-ориентированного программирования* при разработке UI. К концу рассмотрим плюсы и минусы отдельных идей и подходов, применяемых в существующих популярных фреймворках.

Вряд ли приведённые здесь мысли будут напрямую полезны при повседневной разработке конкретных UI-приложений на конкретном фреймворке. Скорее, будет больше погружения в детали, что у фреймворков "под капотом", вопросы архитектуры и внутреннего устройства фреймворков, взгляд "под другим углом". Это может оказаться полезным для понимания работы популярных фреймворков, с которыми часто приходится иметь дело на практике, или же для разработки собственного фреймворка.

Стоит уточнить, что понимается под словом "фреймворк" в данной статье, потому что часто граница между набором библиотечных решений и полноценным каркасом приложений бывает размыта. Одни считают, что React с его соглашениями и экосистемой - это уже фреймворк, а другие утверждают, что Angular - это слишком низкоуровневый фреймворк, который, скорее, тянет на библиотеку. В этой статье не будет рассуждений о том, что такое фреймворк и что такое библиотека. Под словами "UI-фреймворк" будет пониматься библиотека или набор библиотечных решений, устанавливающих некоторый собственный слой абстракций в построении UI, так как именно на этих темах и будет сосредоточено внимание. Но в целом, рассуждения можно применить и к более "готовым к использованию" решениям с богатыми библиотеками строительных блоков.

![UI Title](images/ui_title.svg)

Ограничимся рассмотрением только *графических UI*, которые правильнее называть GUI. Кроме них существуют интерфейс командной строки (CLI), голосовое управление, чат-боты и разные виды гибридных решений. Но в статье для будет применяться аббревиатура UI именно для графических интерфейсов.

***Не будут*** рассматриваться такие интересные темы как *Server-Side Rendering* (SSR) и *Backend-driven UI* (BDUI) для простоты изложения. При этом, некоторые мысли будут применимы и к UI-фреймворкам, требующим участия сервера, например, стилизация.

Графические UI будут рассматриваться в предположении, что они являются частью интерактивных *клиентских приложений*, имеющих своё локальное состояние редактируемых данных. То есть, не будут рассматриваться совсем "тонкие клиенты", отвечающие только за отображение элементов UI и проброс пользовательских действий по сети на обработку на сервер. В основном, речь пойдёт про клиентские приложения, рассчитанные быть достаточно интерактивными и динамичными. Разумеется, не настолько динамичными, как в видеоиграх.

![UI Title](images/ui_form.svg)

UI можно рассмотреть с трёх сторон:

- как его понимает **пользователь**
- как его понимает **разработчик**
- какая **математика** есть в его основе

Это перекликается с подходом к проектированию DDD (Domain-Driven Design) при разработке программных систем целиком. К разработке UI-фреймворка можно применить тот же принцип *абстрагирования* от деталей реализации путём описания упрощённой ментальной *модели* в терминах проблемной области (домена) на всем понятном языке терминов (ubuquitious language). Говоря по простому, можно выделить:

- **домен** - то как понимает UI-элементы пользователь
- **реализация** - то, как разработчик представляет поведение UI, выраженное в деталях работы *целевой платформы*
- **паттерны**, **парадигмы**, **архитектура** - абстракции, которые повторяются от фреймворка к фреймворку

Эти три аспекта будут рассмотрены подробнее в последующих разделах. А пока отметим лишь некоторые наблюдения.

Все UI-фреймворки во многом похожи и повторяют друг за другом одни и те же идеи:

- **Компонентный** подход
- Отделение **View State** от логики **View**
- **Стили**, применяемые глобально в виде правил, как *темы* оформления для View
- Логика обновления View через **реактивное программирование**
- Выделение данных модели в **State Manager** с логикой их изменения через применение **actions**
- **Асинхронная обработка событий** без блокировки самих элементов UI
- **Декларативное программирование** с применением DSL и шаблонов

В существующих популярных фреймворках эти вещи реализуются и совмещаются между собой в тем или иным успехом.

Целью рассуждений будет придти к рекомендациям по улучшению UI-фреймворков или их эффективному их использованию:

- Упрощение понимания кода UI разработчиком для облегчения разработки, тестирования и поддержки
- Упрощение внутренней реализации UI-фреймворка при сохранении эффективности оптимизаций

Эти цели планируется достигать с помощью следующих подходов:

- Прояснение абстракций и стоящих за ними соглашений, предположений и гарантий
- Стремление к понятному отражению этих абстракций в коде
- Стремление к максимально возможной строгости при реализации абстракций
- Использование предположений и гарантий, которые дают абстракции, для выполнения более сложных оптимизаций

Если коротко, то основная идея при создании оптимального UI-фреймворка - это определение DSL с ясной и строгой семантикой для декларативного описания структуры и поведения UI, и разработка компилятора для него, максимально использующего семантику для генерации оптимизированного кода, не уступающего Vanilla JS.

Идея не нова, но в отличие от аналогичных решений будет попытка пойти дальше:

- Семантика DSL будет строится только на парадигмах функционального и реактивного программирования, а императивные операции будут строго ограничены
- Отказ от virtual DOM в пользу прямой, но оптимальной работы с DOM-узлами
- Декларативная "fine-graned reactivity", упрощающая developer-experience при работе с "сигналами" и "computed" (или "memo")
- Компилятор, способный избавить результирующий код от лишних накладных расходов "fine-graned reactivity"
- Компилятор, выполняющий сложные оптимизации крупных фрагментов UI с учётом семантики строгого DSL в дополнение к универсальным оптимизациям для JavaScript

## Доменная модель UI

С точки зрения *домена*, любой UI - это некоторое дерево связанных между собой узлов с определённой семантикой элементов пользовательского интерфейса (кнопок, текста, полей ввода, рамок, картинок и т.п.), правилами отображения на экране и реакциями на взаимодействие с пользователем:

- **Структура** - семантическая древовидная структура элементов UI
- **Стили** - правила для отображения отдельных элементов и фрагментов UI в зависимости от контекста
- **Поведение** - возможности для совершения действий пользователем, реакция на них и на другие события

Структура UI - это абстрактное дерево элементов с определённой семантикой. Она строится на основе структуры тех данных, с которыми работает пользователь. Такие данные обычно называют *моделью* (в терминах MVC), или *состоянием* (state) приложения. UI дополняет модель удобными возможностями для просмотра, навигации и редактирования своим *состоянием представления* (view state).

Стили - это не только CSS. К стилизации можно отнести и более сложные правила трансформации структуры UI в итоговое *представление* (view). Само представление состоит из примитивных элементов, организованных в дерево. Их реализация определяется *целевой платформой* (например, DOM-дерево или scene graph).

Поведение UI опирается на поведение модели из предметной области и дополняется логикой поведения самих элементов представления (например, состояние курсора, выделения, позиция прокрутки и т.п.). Логика поведения обычно описывается как различные реакции на взаимодействия с пользователем и события. К инициаторам логики поведения можно отнести:

- пользовательские действия (actions)
- события (events), происходящие в самой системе (например, таймеры, завершение загрузки и т.п.)

Реакции могут быть сложными. По завершению одних реакций могут запускаться другие. UI может проходить через целую последовательность состояний, которую можно описать автоматной моделью той или иной сложности. Движение по графу переходов управляется событиями и действиями и может быть синхронным и асинхронным. Отдельные части UI могут исполнять реакции параллельно. Тем не менее, в достаточно большой доле простых случаев логику реакций можно описать декларативно. Если мы хотим, чтобы UI был предельно понятен пользователю, то и описание реакций в коде не должно выглядеть излишне сложным.

Модель, которая редактируются с помощью UI - это не просто state, состоящий из примитивных сгруппированных данных. Некоторые данные могут быть лишь отражением других данных и периодически синхронизироваться с ними. Например, данные на UI могут быть лишь отражением данных на сервере. Или одни данные являются лишь результатом вычислений над другими данными.

![Client application](images/client_app.svg)

Похожим образом устроены все UI-фреймворки для клиентских приложений: Web, Desktop, Mobile. Фреймворки повторяют одни и те же идеи архитектуры, но реализация может существенно различаться.

### Компонентный подход

Пользователь "мыслит" (представляет себе) UI в структурированном виде, может разделять его на независимые логические блоки, выделять повторно используемые блоки, представлять себе правила, по которым применяются стили и интуитивно предсказывать поведение при взаимодействии с некоторыми элементами. Компонентный подход в чём-то помогает отражать мышление пользователя. Он позволяет определять структуру UI, которую интуитивно ожидает пользователь, привязывая к ней всё остальное - правила отображения и поведение.

![Component tree](images/component_tree.svg)

**Компонент** - это абстрактная единица, которая совмещает в себе часть структуры UI, связанные с ней локальные стили и логику поведения. Можно сказать, что это самостоятельный блок полноценного UI, который можно повторно использовать как шаблон, меняя в нём изменяемые параметры. Использование компонента происходит путём создания его **экземпляра**. Экземпляров одного компонента может быть много, они могут быть созданы с различными параметрами и присутствовать в разных местах структуры UI.

![Component inside](images/component_inside.svg)

Компоненты в первую очередь позволяют выстроить блоки UI в дерево, определяя семантическую структуру UI, которая является общей для пользователя и разработчика.

Далее, компоненты отвечают за свою локальную логику применения стилей - не только inline-стилей, но и композицию общих повторно используемых стилей, связанных, например, с темой оформления и дизайн-системой.

И, наконец, компоненты отвечают за реализацию логики поведения - реакцию на события и изменения данных.

Компоненты проектируются так, чтобы их можно было совмещать друг с другом. Обычно это происходит путём **композиции**. Каждый компонент может быть рассчитан быть вставленным куда угодно в произвольный контекст, так и принять внутрь себя другие произвольные компоненты. Композиции может подвергаться как структура UI-элементов, так и стили и логика поведения.

При грамотном проектировании компонентов каждый компонент наделяется одной *обязанностью* (Single Responsibility). Обязанность отдельных компонентов даже может заключаться *только* в формировании структуры фрагмента UI или *только* в применении стилей или *только* в добавлении логики поведения. Но чаще всего семантика компонентов такова, что существует тесная связь (high cohesion) между структурой, стилями и поведением, и отдельные компоненты обязуются выражать эту связь. Бывают компоненты, которые отвечают *только* за композицию других компонентов, но сами по себе пусты.

В качестве средства типовой композиции компонентов выступают так называемые **шаблоны**. Шаблон позволяет определить, в какой *последовательности* и *иерархической структуре* и с какими *параметрами* должны быть созданы экземпляры компонентов. Если HTML и CSS представляют собой разметку и стили соответственно для описания DOM-дерева, то шаблоны являются разметкой для дерева компонент, параметров их стилей и поведения.

### Отделение View State от логики представления

Логика поведения компонентов бывает такова, что требует наличия локального состояния. Каждый экземпляр компонента имеет своё независимое состояние, которое отражается в его поведении.

Принято разделять реализацию любого компонента на три части:

- **Model** - структура данных со своей логикой внесения изменений
- **View** - UI-элементы, отображаемые на экране и отвечающие за первичную обработку ввода
- **Controller** - произвольная логика поведения

Модель (Model) - это данные, организованные в определённую структуру данных со своим набором операций и ограничений, инвариантами и контрактами. Модель не является частью самого компонента, она может привязываться к экземпляру через props.

Представление (View) реализуется по возможности как пассивная структура примитивных элементов UI без какой-либо сложной организации данных состояния. Оно предоставляет лишь механизм для взаимодействия с целевой платформой отрисовки и обработки событий ввода.

Контроллер (Controller) - это логика работы компонента. Она может быть определена любым подходящим способом описания изменения параметров View во времени при выполнении операций над моделью или внутренним состоянием.

Реализация контроллера подразумевает наличие состояния, которое тоже можно организовать определённым образом, как и Model, опираясь на предметную область и структуру представления. Это и есть **View State** (или View Model).

Всё поведение, за которое отвечает контроллер, можно рассмотреть как:

- **реакции** (reactions) на изменение Model и View State
- выполнение **действий** (actions) над Model и View State.

Контроллер постоянно "наблюдает" за View State и в качестве реакции на изменения состояния выполняет соответствующее *обновление* View. В то же время, контроллер постоянно "наблюдает" за View в ожидании событий. Когда происходит *событие*, соответствующее пользовательской операции над элементами интерфейса, контроллер преобразует его в соответствующее действие над View State и Model. Это действие может быть целой цепочкой операций, растянутой во времени и с асинхронной обработкой.

Важно, что контроллер никогда напрямую не изменяет View State и Model, а запускает action для этих целей.

Контроллер старается привести View в свежее состояние, соответствующее текущему View State, как можно быстрее. При этом пользователь должен увидеть промежуточных состояний частично обновлённого View. Поэтому часто действия собираются в "транзакции" или batches, чтобы выполняться сразу "пачкой", а уже потом выполнять синхронизацию View с состоянием. Если же действия выполняются асинхронно (по таймеру или с ожиданием ответа от сервера), то пользователь может увидеть промежуточное состояние обновления View.

### Жизненный цикл компонентов

Следствием выделения View State можно назвать необходимость введения **жизненного цикла** компонента. Потому что, на самом деле, это в первую очередь жизненный цикл локального состояния компонентов. Именно View State отвечает за развитие экземпляра компонента во времени. И именно для View State должно быть чётко определено, в какой момент оно создаётся и инициализируется первоначальными значениями и в какой момент удаляется.

Компонент вместе со своим локальным состоянием проходит следующие стадии:

- **Создание** (instantiating) экземпляра
- **Рендеринг** (rendering) представления
- **Привязка** (mounting) локального состояния к представлению
- **Ожидание** (waiting) событий
  - **Выполнение** действия (action) по событию
  - **Реакция** (reaction) на изменение состояния
- **Отвязка** (unmounting) логики от представления
- **Уничтожение** (disposing) экземпляра

Когда один компонент использует шаблон для композиции других компонентов, то их жизненные циклы связаны как друг с другом, так и с жизненным циклом родительского компонента, владеющего шаблоном. Любой фрагмент шаблона тоже имеет стадии, которыми управляет владеющий им компонент:

- **Создание** (instantiating) экземпляров компонентов шаблона
- **Рендеринг** (rendering) представления
- **Привязка** (mounting) локального состояния к представлению
- **Отвязка** (unmounting) логики от представления
- **Уничтожение** (disposing) экземпляров компонентов шаблона

View State родительского компонента может быть привязан к отдельным элементам шаблона. Но в любом случае родительский View State живёт дольше, чем экземпляры дочерних компонентов.

### Стили

Компонент определяет правила трансформации View State в структуру View. Но итоговое отображение View средствами целевой платформы определяется **Стилями**. Стили представляются в виде правил, применяемых к состоянию целевой платформы целиком, то есть, потенциально могут действовать для любых узлов и любых экземпляров компонентов.

Браузер как целевая платформа уже предлагает своё нативное решение для стилей, применяемых к DOM-узлам - CSS. Однако, часто этого оказывается не достаточно для применения практик абстрагирования, повторного использования, компонентного подхода и инкапсуляции. За годы существования CSS было придумано много обходных путей, чтобы решать эти проблемы.

Другие платформы, например, HTML5 Canvas, TREE.js, нативные мобильные платформы, не имеют своего встроенного движка CSS.

Каскадное применение

Локальные, изолированные в модули, повторно используемые

Возможности кастомизации

### Реактивное программирование

### Операции редактирования

### Асинхронная обработка событий

### Декларативное программирование

## Сила абстракций

На данный момент были кратко рассмотрены различные аспекты UI-фреймворков и подсвечены некоторые возникающие проблемы. Теперь попробуем предложить, что можно улучшить. Но для начала, в этом разделе постараемся подсветить одну важную проблему, которую часто обходят стороной.

Что есть абстракция? Какие гарантии дают те или иные абстракции? А как мы можем быть уверены в этих гарантиях? А как мы должны поступать, если эти гарантии не выполняются?

Когда требуется декларативное программирование со строгими абстракциями, классический подход с императивным ООП уже не подходит.

UI никогда не будет эффективно описываться чистым функциональными программированием.

UI никогда не будет эффективно описываться ООП.

UI никогда не будет полагаться лишь на реактивное программирование.

Или на какую-либо ещё парадигму (аспектно-ориентированное программирование).

И Dependency injection вовсе не обязателен при разработке приложений.

Зачем же мы тогда рассматриваем это всё и подчёркиваем сильные стороны?

Наша задача - сделать DSL, соответствующей ментальной модели UI, которую мы очертили в проблемной области (домене). А все парадигмы и стили программирования следует рассматривать как конструкторы DSL.

### Проблемы JavaScript для разработки UI

JavaScript как он есть не подходит для удобной разработки логики UI, потому что имеет ряд проблем:

- мало средств для создания строгих абстракций
- ограничения синтаксиса не позволяют выражать логику достаточно декларативно
- трудно корректно типизировать с помощью TypeScript
- из коробки не позволяет следовать парадигмам функционального и реактивного программирования

Тем не менее, он не достаточно "плох", чтобы найти сильные аргументы против него и отказаться от его использования. Тем более, для браузера альтернатив почти нет. JavaScript имеет много достоинств, в первую очередь, таких, которые позволяют использовать с достаточной простотой "механизмы" для реализации самых разнообразных концепций в программировании. Просто он не имеет достаточно средств, чтобы удобно "запрещать" что-либо программисту. А такое часто бывает необходимо. Можно смотреть на JavaScript как на современный LISP.

JavaScript - это императивный ООП с замыканиями. Это ни в коем случае не язык функционального программирования. То, что в нём можно писать в "функциональном стиле" не делает его языком с парадигмой функционального программирования. Потому что сам язык предоставляет мало средств, чтобы придерживаться функциональной парадигмы. И часто в итоге получается, что "функциональный стиль" JavaScript держится лишь на соглашениях и на совести разработчиков. Потому что из-за всех возможностей JavaScript соблюдение этих соглашений трудно проверить типизацией и статическим анализом без существенного ограничения языка.

Тем не менее, в JavaScript, как и во многих языках с ООП, есть средства для обеспечения гарантий выполнения некоторых абстракций. Во-первых, есть возможности const-переменных, неизменяемых полей и getters без setters. Во-вторых, есть способы строгой инкапсуляции, которые с развитием современного JavaScript становятся всё удобнее. Это отсутствие доступа к локальным переменным и параметрам замыканий, ES-модули и приватные поля классов. С помощью этих элементарных средств ограничения становится возможным делать слои сильных абстракций, но на это надо потратить много усилий при разработке, чтобы не допустить "дыру" или "протечку" в абстракции.

Ещё JavaScript как он есть не позволяет выполнять сложные оптимизации над кодом. Оптимизаторы, чтобы выполнить некоторые полезные и очевидные оптимизации типа минификации, инлайнинга и удаления неиспользуемого кода, пользуются предположениями том, что код проекта написан определённым образом и не содержит хитрых хаков. И если код написан в более строгих соглашениях, позволяющих куда более эффективные оптимизации, оптимизаторы это сделать не могут, потому что эти соглашения не гарантированы и их в принципе трудно проверить статическим анализом.

### Шаблоны и DSL

Декларативный DSL представляется как язык, на котором можно в *формальном* (строгом) виде выразить мысль так, что по структуре код будет напоминать неформальное описание задачи и её решения на естественном языке или псевдокоде. JavaScript в связке с TypeScript даёт много мощных средств для создания строгих DSL, но их не достаточно.

Большинство существующих фреймворков так или иначе делают свой DSL на JS или свой DSL шаблонов с вкраплением JS. Мало фреймворков, которые используют свой честный DSL шаблонов со строгими гарантиями.

## Вопросы реализации UI-фреймворков

Можно выделить несколько групп вопросов реализации UI-фреймворка:

- Декларативный DSL, его парсинг и интерпретация
- работа с целевой платформой
- реактивное программирование как логика обновления представления при обновлении состояния

### DSL

Два подхода к реализации фреймворка:

- Frameworkless - снизу вверх, сборка из элементарных библиотек с максимальным прямым использованием средств платформы
- Сверху вниз, начиная с создания своего языка и сильных абстракций с минимизацией прямого обращения к средствам платформы

Примерно такое же разделение отражается в способах проектирования DSL:

- Взять элементарные возможности платформы и способ их композиции, построить DSL как библиотеку для универсального языка
- Спроектировать DSL исходя из домена, а затем задуматься о реализации на целевой платформе, построить DSL как транслятор

### Целевая платформа UI

Обычно, это почти такое же дерево элементов с семантикой UI, но с меньшими возможностями и нехваткой декларативности.

Иногда это просто движок отрисовки графической сцены и обработки в вода. К нему нужно добавить реализацию layout и применения стилей, обработку событий. В итоге получится примерно то же, что и DOM.

Но можно в качестве целевой платформы использовать и другой UI-фреймворк.

### Реализация реактивности во фреймворках

Задача в том, чтобы при изменении модели или view state выполнить необходимые изменения view средствами целевой платформы.

View state может обновляться разными способами:

- точечные изменения значений
- изменения структуры дерева данных
- замена больших фрагментов данных на новые

Целевая платформа тоже может предоставлять API для изменения состояния UI различными способами:

- точечные изменения элементов UI или примитивов сцены
- Замена фрагментов
- полная перерисовка экрана

Реализации реактивности можно разделить по моменту, когда выполняется reconciliation:

- fine-graned reactivity
- reconciliation данных
- vDOM reconciliation
- полная перерисовка экрана

Fine-graned reactivity может строиться по push- и pull-модели.

### Реактивность самого DOM

CSS reflow
CSS variables

### Компиляция шаблонов
